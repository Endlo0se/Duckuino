/*
 *  Dckuino.js, an open source project licenced under MIT License
 */

/* jshint esversion: 6 */
/* jshint laxbreak: true */

var commandMap = { // Key that can be typed
  ESCAPE:'177',
  ESC:'177',
  GUI:'131',
  WINDOWS:'131',
  COMMAND:'131',
  MENU:'229',
  APP:'229',
  END:'213',
  SPACE:'32',
  TAB:'179',
  PRINTSCREEN:'206',
  ENTER:'176',
  RETURN:'176',
  UPARROW:'218',
  DOWNARROW:'217',
  LEFTARROW:'216',
  RIGHTARROW:'215',
  UP:'218',
  DOWN:'217',
  LEFT:'216',
  RIGHT:'215',
  CAPSLOCK:'193',
  DELETE:'212',
  DEL:'212',
  F1:'194',
  F2:'195',
  F3:'196',
  F4:'197',
  F5:'198',
  F6:'199',
  F7:'200',
  F8:'201',
  F9:'202',
  F10:'203',
  F11:'204',
  F12:'205',
  PAGEUP:'211',
  PAGEDOWN:'214'
};

var comboMap = { // Key that can only be used in combos
  ALT:'130',
  SHIFT:'129',
  CTRL:'128',
  CONTROL:'128'
};

var keyMap = { // Normal keys
  a:'97',
  b:'98',
  c:'99',
  d:'100',
  e:'101',
  f:'102',
  g:'103',
  h:'104',
  i:'105',
  j:'106',
  k:'107',
  l:'108',
  m:'109',
  n:'110',
  o:'111',
  p:'112',
  q:'113',
  r:'114',
  s:'115',
  t:'116',
  u:'117',
  v:'118',
  w:'119',
  x:'120',
  y:'121',
  z:'122'
};

class Dckuinojs {
  constructor() {
    this.keyMap = keyMap;
    this.commandMap = commandMap;
    this.comboMap = comboMap;
  }

  toArduino(inputCode)
  {
    // Check if the parameter is empty or undefined
    if (inputCode === '' || inputCode === undefined)
    {
      console.error('Error: No ducky script was entered !');
      return false;
    }  // Parsing

    var parsedDucky = this._parse(inputCode);
    if (parsedDucky === '' || parsedDucky === undefined)
    {
      return false;
    }  // Returning the total uploadable script
    return 'Rem:Generated by Dckuino.js by NURRL\n'
    + 'Rem:Modified for use with ESPloit by Corey Harding\n'
    + 'Rem:-----\n'
    + parsedDucky;
  }

  // The parsing function
   _parse(toParse)
  {
    // Init chronometer
    var timerStart = Date.now();

    // Preset all used vars
    var parsedScript = '';
    var lastLines;
    var lastCount;
    var parsedOut = '';

    var commandKnown = false;
    var noNewline = false;

    var wordArray;
    var wordOne;

    // Replace "<" with "&lt;" to prevent triggering the file upload bug
    toParse = toParse.replace(/</g, '&lt;');

    // Trim whitespaces
    toParse = toParse.replace(/^ +| +$/gm, '');

    // Remove all *ugly* tabs
    toParse = toParse.replace(/\t/g, '');

    // Cut the input in lines
    var lineArray = toParse.split('\n');

    // Loop every line
    for (var i = 0; i < lineArray.length; i++)
    {
      // Line empty, skip
      if (lineArray[i] === '' || lineArray[i] === '\n')
      {
        console.log('Info: Skipped line ' + (i + 1) + ', because was empty.');
        continue;
      }

      // Outputs, for REPLAY/REPEAT COMMANDS
      if (parsedOut !== undefined && parsedOut !== '')
      {
        lastLines = parsedOut;
        lastCount = ((lastLines.split('\n')).length + 1);
      }

      // Reset line buffer
      parsedOut = '';

      // Set to unknown command by default
      commandKnown = false;

      // Cut every line in words & store the first word in a var
      wordArray = lineArray[i].split(' ');
      wordOne = wordArray[0];

      // Parse commands
      switch(wordOne){
        case "STRING":
          wordArray.shift();

          var textString = wordArray.join(' ');

          // Replace all '"' by '\"' and all '\' by '\\'
          textString = textString.split('\\').join('\\\\').split('"').join('\\"');
          if (textString !== '')
          {
            parsedOut = 'Print:' + textString;
            commandKnown = true;
          } else {
            console.error('Error: at line: ' + (i + 1) + ', STRING needs a text');
            return;
          }
          break;
        case "DELAY":
          wordArray.shift();

          if(wordArray[0] === undefined || wordArray[0] === '') {
            console.error('Error: at line: ' + (i + 1) + ', DELAY needs a time');
            return;
          }

          if (! isNaN(wordArray[0]))
          {
            parsedOut = 'CustomDelay:' + wordArray[0];
            commandKnown = true;
          } else {
            console.error('Error: at line: ' + (i + 1) + ', DELAY only accepts numbers');
            return;
          }
          break;
        case "DEFAULTDELAY":
        case "DEFAULT_DELAY":
          wordArray.shift();

          if(wordArray[0] === undefined || wordArray[0] === '') {
            console.error('Error: at line: ' + (i + 1) + ', DEFAULT_DELAY needs a time');
            return;
          }

          if (! isNaN(wordArray[0]))
          {
            parsedOut = 'DefaultDelay:' + wordArray[0];
            commandKnown = true;
          } else {
            console.error('Error: at line: ' + (i + 1) + ', DEFAULT_DELAY only accepts numbers');
            return;
          }
          break;
        case "TYPE":
          wordArray.shift();

          if(wordArray[0] === undefined || wordArray[0] === '') {
            console.error('Error: at line: ' + (i + 1) + ', TYPE needs a key');
            return;
          }

          if (keyMap[wordArray[0]] !== undefined)
          {
            commandKnown = true;
            // Replace the DuckyScript key by the Arduino key name
            parsedOut = 'Press:' + keyMap[wordArray[0]];
          } else {
            console.error('Error: Unknown letter \'' + wordArray[0] +'\' at line: ' + (i + 1));
            return;
          }
          break;
        case "REM":
          wordArray.shift();

          // Placing the comment to arduino code
          if (wordArray.length > 0)
          {
            commandKnown = true;
            parsedOut = 'Rem:' + wordArray.join(' ');
            if (i == (lineArray.length - 1))
              parsedOut += '\n';
          } else {
            console.error('Error: at line: ' + (i + 1) + ', REM needs a comment');
            return;
          }
          break;
        case "REPEAT":
        case "REPLAY":
          wordArray.shift();

          if (wordArray[0] === undefined || wordArray[0] === '') {
            console.error('Error: at line: ' + (i + 1) + ', REPEAT/REPLAY needs a loop count');
            return;
          }

          if (lastLines === undefined)
          {
            console.error('Error: at line: ' + (i + 1) + ', nothing to repeat, this is the first line.');
            return;
          }

          if (! isNaN(wordArray[0]))
          {
            // Remove the lines we just created
            var linesTmp = parsedScript.split('\n');
            linesTmp.splice(-lastCount, lastCount);

            if (linesTmp.join('\n') === '')
              parsedScript = linesTmp.join('\n');
            else {
              parsedScript = linesTmp.join('\n') + '\n';
            }

            // Add two spaces at Begining
            lastLines = lastLines.replace(/^  /gm,'    ');

            parsedOut = lastLines + '\n';
            // Replace them
            while (wordArray[0]>1){
              parsedOut += lastLines + '\n';
              wordArray[0] = wordArray[0]-1;
            }
            parsedOut += lastLines;

            commandKnown = true;
          } else {
            console.error('Error: at line: ' + (i + 1) + ', REPEAT/REPLAY only accepts numbers');
            return;
          }
          break;
        default:
          if (wordArray.length==1){
            if (comboMap[wordArray[0]] !== undefined)
            {
              commandKnown = true;

              parsedOut += 'Press:' + comboMap[wordArray[0]];
            }else if (commandMap[wordArray[0]] !== undefined) {
              commandKnown = true;

              parsedOut += 'Press:' + commandMap[wordArray[0]];
            }else if (keyMap[wordArray[0]] !== undefined) {
              commandKnown = true;

              parsedOut += 'Press:' + keyMap[wordArray[0]];
            }else {
              commandKnown = false;
              break;
            }
            wordArray.shift();
          }
          if (wordArray.length >1){
            if (comboMap[wordArray[0]] !== undefined)
            {
              commandKnown = true;

              parsedOut += 'Press:' + comboMap[wordArray[0]] + '\+';
            }else if (commandMap[wordArray[0]] !== undefined) {
              commandKnown = true;

              parsedOut += 'Press:' + commandMap[wordArray[0]] + '\+';
            }else if (keyMap[wordArray[0]] !== undefined) {
              commandKnown = true;

              parsedOut += 'Press:' + keyMap[wordArray[0]] + '\+';
            }else {
              commandKnown = false;
              break;
            }
            wordArray.shift();
          }
          while (wordArray.length>1){
            if (comboMap[wordArray[0]] !== undefined)
            {
              commandKnown = true;

              parsedOut += comboMap[wordArray[0]] + '\+';
            }else if (commandMap[wordArray[0]] !== undefined) {
              commandKnown = true;

              parsedOut += commandMap[wordArray[0]] + '\+';
            }else if (keyMap[wordArray[0]] !== undefined) {
              commandKnown = true;

              parsedOut += keyMap[wordArray[0]] + '\+';
            }else {
              commandKnown = false;
              break;
            }
            wordArray.shift();
          }
         while (wordArray.length==1){
            if (comboMap[wordArray[0]] !== undefined)
            {
              commandKnown = true;

              parsedOut += comboMap[wordArray[0]];
            }else if (commandMap[wordArray[0]] !== undefined) {
              commandKnown = true;

              parsedOut += commandMap[wordArray[0]];
            }else if (keyMap[wordArray[0]] !== undefined) {
              commandKnown = true;

              parsedOut += keyMap[wordArray[0]];
            }else {
              commandKnown = false;
              break;
            }
            wordArray.shift();
          }
      }

      if (!commandKnown)
      {
        console.error('Error: Unknown command or key \'' + wordArray[0] + '\' at line: ' + (i + 1) + '.');
        return;
      }

      parsedScript += parsedOut; // Add what we parsed

      if (!noNewline)
        parsedScript += '\n'; // Add new line
    }

    var timerEnd = Date.now();
    var timePassed = new Date(timerEnd - timerStart);

    console.log('Done parsed ' + (lineArray.length) + ' lines in ' + timePassed.getMilliseconds() + 'ms');
    return parsedScript;
  }
}
